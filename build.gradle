/* (c) https://github.com/MontiCore/monticore */
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.gradle.api.tasks.JavaExec

plugins {
    id "java"
    id "monticore" version "$mc_version" // MontiCore Plugin
    id "maven-publish"
    id "com.github.johnrengelman.shadow" version "6.0.0"
    id "io.github.themrmilchmann.ecj" version "0.2.0"
}

description = "Statecharts"
buildDir = file("$projectDir/target")


def grammarDir = "src/main/grammars"
def grammarOutDir = "$buildDir/generated-sources/mc"
def grammarTROutDir = "$buildDir/generated-sources/mc_tr"
def grammarTagOutDir = "$buildDir/generated-sources/mc_tag"
def testGrammarOutDir = "$buildDir/generated-test-sources/mc"
def testSCOutDir = "$buildDir/generated-test-sources/sc"
def testscgenDir = "$projectDir/src/testscgen"

def withTR = ("true").equals(getProperty('genTR'));
def withTagging = ("true").equals(getProperty('genTagging'));


// configure non-standard source sets
sourceSets {
  main {
    java.srcDirs += [grammarOutDir]
  }
  test {
    java.srcDirs += ["$testGrammarOutDir"]
  }
  grammars {
    resources {
      srcDirs(grammarDir)
      include "**/*.mc4"
    }
  }

  testscgen {
    java.srcDirs += ["$testSCOutDir"]

    java {}
  }
  trafo {
    java.srcDirs = [grammarTROutDir]
  }
  tagging {
    java.srcDirs = [grammarTagOutDir]
  }
}

// Trafo and Tagging related grammars & their artifacts are published separately
configurations {
  testscgenImplementation.extendsFrom(implementation)
  testscgenImplementation.extendsFrom(testImplementation)
  grammar
  trafo
  tagging
}

dependencies {
  grammar("de.monticore:monticore-grammar:$mc_version") {
    capabilities {
      requireCapability("de.monticore:monticore-grammar-grammars")
    }
  }
  implementation "com.google.guava:guava:$guava_version"
  implementation  "de.monticore:monticore-runtime:$mc_version"
  implementation "de.monticore:monticore-grammar:$mc_version"
  implementation "de.monticore:class2mc:$mc_version"
  implementation "de.se_rwth.commons:se-commons-logging:$mc_version"
  implementation "de.se_rwth.commons:se-commons-utilities:$mc_version"
  implementation group: 'org.antlr', name: 'antlr4-runtime', version: antlr_version
  implementation group: 'de.monticore.lang', name: 'cd4analysis', version: mc_version
  implementation "commons-cli:commons-cli:$commons_cli_version"
  implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.11'
  implementation group: 'commons-io', name: 'commons-io', version: '2.8.0'
  testImplementation "junit:junit:$junit_version"
  implementation 'org.apache.groovy:groovy:4.0.2'

  testscgenImplementation(sourceSets.main.output.classesDirs)
  testscgenImplementation(sourceSets.test.output.classesDirs)

  trafoImplementation "de.monticore:monticore-grammar-trafo:$mc_version"
  trafoCompileOnly project(path)
  trafoCompileOnly "de.monticore:monticore-runtime:$mc_version" // can be removed if java-library api is used above
  trafoCompileOnly "de.monticore:monticore-grammar:$mc_version" // can be removed if java-library api is used above

  taggingImplementation "de.monticore:monticore-grammar-tagging:$mc_version"
  taggingCompileOnly project(path)
  taggingCompileOnly "de.monticore:monticore-runtime:$mc_version" // can be removed if java-library api is used above
  taggingCompileOnly "de.monticore:monticore-grammar:$mc_version" // can be removed if java-library api is used above
}

repositories {
    if (("true").equals(getProperty('useLocalRepo'))) {
        mavenLocal()
    }
    maven {
        credentials.username mavenUser
        credentials.password mavenPassword
        url repo
    }
}

task generate {}
task generateTR {}
task generateTag {}

// one task per grammar file
fileTree(grammarDir).matching { include '**/*.mc4'}.each { g ->
  def taskname = "generateGrammar${g.getName().substring(0,g.getName().lastIndexOf('.'))}"
  task  "$taskname" (type: MCTask) {
    grammar = g
    outputDir = file grammarOutDir
    def grammarIncludingPackage = file(grammarDir).toURI().relativize(g.toURI()).toString()
    outputs.upToDateWhen { incCheck(grammarIncludingPackage)}
  }
  generate.dependsOn ("$taskname")
  task "${taskname}TR"(type: MCTask) {
    onlyIf {withTR}
    grammar = getTRFile(g, file(grammarOutDir))
    // Replace with getTRFile(g) once the plugin is updated and in the upstream
    outputDir = file grammarTROutDir
    isDSTL = true
    modelPath(grammarOutDir)
    modelPath(file(grammarDir).toString())
    def grammarIncludingPackage = file(grammarDir).toURI().relativize(g.toURI()).toString()
    def trGrammarIncludingPackage = file(grammarOutDir).toURI().relativize(file(grammar).toURI()).toString()
    outputs.upToDateWhen { incCheck(grammarIncludingPackage) }
    outputs.upToDateWhen { incCheck(trGrammarIncludingPackage) }
    dependsOn(generate)
  }
  generateTR.dependsOn("${taskname}TR")
  task "${taskname}TagDef"(type: MCTask) {
    onlyIf {withTagging}
    grammar = getTagDefinitionFile(g, file(grammarOutDir))
    outputDir = file grammarTagOutDir
    modelPath(grammarOutDir)
    modelPath(file(grammarDir).toString())
    dependsOn(generate)
    genTag = true
  }
  task "${taskname}TagSchema"(type: MCTask) {
    onlyIf { withTagging }
    grammar = getTagSchemaFile(g, file(grammarOutDir))
    outputDir = file grammarTagOutDir
    modelPath(grammarOutDir)
    modelPath(file(grammarDir).toString())
    dependsOn(generate)
  }
  generateTag.dependsOn("${taskname}TagDef")
  generateTag.dependsOn("${taskname}TagSchema")
}

compileTrafoJava.dependsOn compileJava
compileTaggingJava.dependsOn compileJava


compileJava.dependsOn generate
compileTrafoJava.dependsOn generateTR
compileTaggingJava.dependsOn generateTag

task generateSC(type: JavaExec) {
  classpath = sourceSets.main.runtimeClasspath

  mainClass = "de.monticore.umlstatecharts/UMLStatechartsTool"

  args("-i", "${testscgenDir}/resources/examples/DoorExample.sc",
          "-gen", "${testSCOutDir}",
          "-hcp", "${testscgenDir}/java")
}

generateSC.dependsOn compileJava
compileTestscgenJava.dependsOn generateSC
check.dependsOn testscgenClasses

tasks.withType(Test) {
    maxParallelForks = Runtime.runtime.availableProcessors() ?: 1
}

tasks.withType(JavaCompile) {
    options.fork = true
    options.encoding = "UTF-8"
    options.deprecation false
    options.warnings = false
    options.headerOutputDirectory.convention(null)
}

// Bundle and publish the generated trafo artifacts separately as ${projectname}-trafo
tasks.register('trafoJar', Jar) {
  onlyIf {withTR}
  from sourceSets.trafo.output
  group 'build'
}
tasks.register('trafoSourcesJar', Jar) {
  onlyIf {withTR}
  from sourceSets.trafo.java
  group 'build'
}
artifacts {
  trafo(trafoJar)
}

// Bundle and publish the generated tagging artifacts separately as ${projectname}-tagging
tasks.register('taggingJar', Jar) {
  onlyIf {withTagging}
  from sourceSets.tagging.output
  group 'build'
}
tasks.register('taggingSourcesJar', Jar) {
  onlyIf {withTagging}
  from sourceSets.tagging.java
  group 'build'
}
artifacts {
  tagging(taggingJar)
}

// all in one tool-jar
shadowJar {
    manifest {
        attributes "Main-Class": "de.monticore.umlstatecharts.UML${archiveBaseName.get().capitalize()}Tool"
    }
    archiveClassifier = "mc-tool"
    archiveFileName = "MC${archiveBaseName.get().capitalize()}.${archiveExtension.get()}"
}

task uMLSCTransGenerator(type: ShadowJar) {
    onlyIf {withTR}
    dependsOn shadowJar
    group = "shadow"
    manifest.attributes 'Main-Class': 'de.monticore.tr.UMLStatechartsTFGenTool'
    archiveFileName = 'UMLSCTransGenerator.jar'
    archiveClassifier.set('umltfgen')
    from zipTree(shadowJar.archiveFile)
    from zipTree(trafoJar.archiveFile)
    configurations += [project.configurations.trafoRuntimeClasspath]
}

task triggeredSCTransGenerator(type: ShadowJar) {
    onlyIf {withTR}
    dependsOn shadowJar
    group = "shadow"
    manifest.attributes 'Main-Class': 'de.monticore.tr.TriggeredStatechartsTFGenTool'
    archiveFileName = 'TriggeredSCTransGenerator.jar'
    archiveClassifier.set('triggeredtfgen')
    from zipTree(shadowJar.archiveFile)
    from zipTree(trafoJar.archiveFile)
    configurations += [project.configurations.trafoRuntimeClasspath]
}

task testReport(type: TestReport) {
    destinationDir = file("$buildDir/reports/allTests")
    // Include the results from the 'test' task
    reportOn tasks.withType(Test)
}

/**
 * Integration with MLC language and tool
 */
task checkArtifacts { group = 'mlc' }
configurations { MLC }
dependencies { MLC(group: 'de.monticore.lang', name: 'mlc-tool', version: mlc_version) }
StringJoiner joiner = new StringJoiner(" ")
configurations.compileClasspath.resolve().each { joiner.add(it.toString()) }
configurations.grammar.resolve().each { joiner.add(it.toString()) }
joiner.add "$projectDir/target/symbols"
String mp = joiner.toString()

// two tasks per MLC file
fileTree("src").matching { include '**/*.mlc' }.each {
    def f = it
    def mlcName = it.getName().substring(0, it.getName().lastIndexOf('.'))

    task "showArtifacts${mlcName}"(type: JavaExec) {
        classpath = configurations.MLC
        group = 'mlc'
        mainClass = 'de.monticore.mlc.MLCTool'
        args "-input", f, "-projectDir", projectDir, "-mp", mp, "-s", "-all"
        dependsOn("generateGrammar${mlcName}")
    }

    task "checkArtifacts${mlcName}"(type: JavaExec) {
        classpath = configurations.MLC
        group = 'MLC'
        mainClass = 'de.monticore.mlc.MLCTool'
        args "-input", f, "-projectDir", projectDir, "-mp", mp, "-s", "-check"
        dependsOn("generateGrammar${mlcName}")
        checkArtifacts.dependsOn("checkArtifacts${mlcName}")
    }
}    // end integration with MLC


java {
    withSourcesJar()
    registerFeature('grammars') {
        usingSourceSet(sourceSets.grammars)
    }
}

sourcesJar.dependsOn project.collect { it.tasks.withType(MCTask) }

jar.dependsOn grammarsJar, shadowJar

if (withTR) {
  build.dependsOn triggeredSCTransGenerator, uMLSCTransGenerator
}

// configure deployment
publishing {
    // configure what artifacts to publish
    publications {
      mavenJava(MavenPublication) {
        from components.java
      }
      if (withTR) {
        "trafo"(MavenPublication) {
          artifactId = project.name + "-trafo"
          artifact tasks.trafoJar { appendix 'trafo' }
          artifact tasks.trafoSourcesJar { appendix 'trafo'; classifier 'sources' }
          artifact triggeredSCTransGenerator
          artifact uMLSCTransGenerator
        }
      }
      if (withTagging) {
        "tagging"(MavenPublication) {
          artifactId = project.name + "-tagging"
          artifact tasks.taggingJar { appendix 'tagging' }
          artifact tasks.taggingSourcesJar { appendix 'tagging'; classifier 'sources' }
        }
      }
    }
    repositories.maven {
        credentials.username mavenUser
        credentials.password mavenPassword
        def releasesRepoUrl = "https://nexus.se.rwth-aachen.de/content/repositories/monticore-releases/"
        def snapshotsRepoUrl = "https://nexus.se.rwth-aachen.de/content/repositories/monticore-snapshots/"
        url = version.endsWith("SNAPSHOT") ? snapshotsRepoUrl : releasesRepoUrl
    }
}

task buildAll(type: GradleBuild) {
    tasks = ['build']
}

defaultTasks('build')
